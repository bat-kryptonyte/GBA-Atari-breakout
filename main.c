#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/start.h"
#include "images/gradient.h"
#include "images/target.h"
#include "images/wasted.h"
#include "images/win.h"
/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //

  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  int score = 0;
  int final_score;
  int high_score;

  

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
    switch (state) {
      case START:
        drawFullScreenImageDMA(start);
        int col = 130;
        int row = 95;
        int speed = 2;


        while(1) {
          delay(1);
          drawRectDMA(row, col, 105, 10, BACKGROUND);
          waitForVBlank();
          col += speed;

          if(col < 0) {
              col = 0;
              speed = - speed;
          }
          if(col > WIDTH - 105) {
              col = WIDTH - 105;
              speed = -speed;
          }
          drawString(row, col, "PRESS UP TO START", WHITE);
          if (KEY_DOWN(BUTTON_UP, BUTTONS)) {
            drawRectDMA(0,0,WIDTH,HEIGHT,BLACK);
            state = PLAY;
            break;
          }


        }


        // state = ?
        break;
      case PLAY:;
        score = 0;
        char result[30];
        int player_velocity = 3;
        int ball_velocity = 2;

        struct target_state cts, pts;
        struct g_target *tp, *otp;

        for (int i = 0; i < NUM_TILES; i++) {
          cts.targets[i].hit = 0;
        }


        struct ball *bp, *obp;
        struct state cs, ps;

        cs.gamestate = GS_INITBOUNCE;
        cs.size = 5;
        bp = &cs.balls;
        bp->row = 80;
        bp->col = 120;
        bp->cd = ball_velocity;
        bp->rd = ball_velocity;
        bp->color = WHITE;


        struct player *rp, *orp;
        struct player_state crs, prs;
        crs.width = 24;
        crs.height = 8;
        rp = &crs.players;
        rp -> row = 120;
        rp -> col = 120;
        rp -> cd = player_velocity;
        rp -> rd = player_velocity;
          // Run forever (or until the power runs out)
        
          while (1) {

            if (KEY_DOWN(BUTTON_SELECT, BUTTONS)) {
              state = START;
              break;
              
            }
            //score
            drawString(140, 10, "SCORE: ", WHITE);
            sprintf(result, "%d", score);
            drawRectDMA(140, 50, 20, 20, BLACK);
            drawString(140, 50, result, WHITE); 
            if (score == NUM_TILES) {
              final_score = score;
              high_score = 0;
              if (high_score > final_score) {
                high_score = final_score;
              }
              state = WIN;
              break;
            }

            //change ball velocity depending on number of tiles left:
              if (score > 10 && score < 20) {
                ball_velocity = 3;
                player_velocity = 5;
              }
              if (score >= 20) {
                ball_velocity = 4;
                player_velocity = 7;
              }



            //tiles
              pts = cts;
              int row_disp = 0;
              int col_disp = 3;
              for (int i = 0; i < NUM_TILES; i++) {

                cts.targets[i].row = 10 + row_disp;
                cts.targets[i].col = col_disp;
                cts.targets[i].width = 20;
                cts.targets[i].height = 10;
                if (col_disp > 200) {
                  col_disp = 3;
                  row_disp += 20;
                } else {
                 col_disp += 21;

                }
              }
              
          // See if we need to bounce off a wall
              ps = cs;
              bp = &cs.balls;
              bp->cd = ball_velocity * (bp->cd < 0 ? -1 : 1);
              bp->rd = ball_velocity * (bp->rd < 0 ? -1 : 1);
              rp->cd = player_velocity;
              bp->row = bp->row + bp->rd;
              bp->col += bp->cd;
              if(bp->row < 0) {
                bp->row = 0;
                bp->rd = -bp->rd;
              }
              if(bp->row > HEIGHT - 5) {
                // bp->row = HEIGHT - 5;
                // bp->rd = -bp->rd;
                state = LOSE;
                final_score = score;
                break;
              }
              if(bp->col < 0) {
                bp->col = 0;
                bp->cd = -bp->cd;
              }
              if(bp->col > WIDTH - 5) {
                bp->col = WIDTH - 5;
                bp->cd = -bp->cd;
              }
              if (((bp -> row > rp -> row && bp -> row < rp -> row + crs.height) || (bp -> row + cs.size > rp -> row && bp -> row + cs.size < rp -> row + crs.height)) && bp -> col > rp -> col && bp -> col < rp -> col + crs.width) {
                
                bp->rd = -bp->rd;

              }
              for (int i = 0; i < NUM_TILES; i++) {
                 if (cts.targets[i].hit == 0 && ((bp -> row > cts.targets[i].row && bp -> row < cts.targets[i].row + cts.targets[i].height) || (bp -> row + cs.size > cts.targets[i].row && bp -> row + cs.size < cts.targets[i].row + cts.targets[i].height)) && bp -> col > cts.targets[i].col && bp -> col < cts.targets[i].col + cts.targets[i].width) {
                
                    bp->rd = -bp->rd;
                    cts.targets[i].hit = 1;
                    score++;

                }
              }
          //player
              prs = crs;
              rp = &crs.players;
              if (KEY_DOWN(BUTTON_LEFT, BUTTONS)) {

                if (rp->col < 5) {
                  rp->col = 5;
                }
                rp->col = rp->col - rp->cd;
              }
              if (KEY_DOWN(BUTTON_RIGHT, BUTTONS)) {
                if (rp->col > WIDTH - 5 - crs.width) {
                  rp->col = WIDTH - 5 - crs.width;
                }
                rp->col = rp->col + rp->cd;
                
              }
          
// Draw the ball
              delay(1);
              waitForVBlank();
              for (int i = 0; i < NUM_TILES; i++) {

                otp = &pts.targets[i];
                if (otp->hit == 1) {
                  drawRectDMA(otp -> row, otp -> col, 20, 10, BLACK);
                } else {
                  continue;
                }
              }
              for (int i = 0; i < NUM_TILES; i++) {
                tp = &cts.targets[i];
                if (tp->hit == 0) {
                  drawImageDMA(tp -> row, tp -> col, 20, 10, target);
                } else {
                  continue;
                }
              }

              obp = &ps.balls;
              drawRectDMA(obp->row, obp->col,
                ps.size, ps.size,
                BLACK);
              bp = &cs.balls;
              drawRectDMA(bp->row, bp->col, cs.size, cs.size, bp->color);
              
              orp = &prs.players;
              drawRectDMA(orp->row, orp->col, prs.width, prs.height, BLACK);
              rp = &crs.players;
              drawImageDMA(rp->row, rp->col, crs.width, crs.height, gradient);
          } // Game Loop
           
        // state = ?
        break;
      case WIN:

        drawFullScreenImageDMA(win);
        final_score = score;

        if (final_score > high_score) {
            high_score = final_score;
        }

        char result3[30];
        char result4[30];
        while(1) {

          drawString(10, 10, "PRESS BACKSPACE TO START AGAIN", WHITE);

          drawString(140, 10, "YOUR SCORE: ", WHITE);
          sprintf(result3, "%d", final_score);
          drawString(140, 80, result3, WHITE); 
          drawString(150, 10, "HIGH SCORE: ", WHITE);
          sprintf(result4, "%d", high_score);
          drawString(150, 80, result4, WHITE); 


          if (KEY_DOWN(BUTTON_SELECT, BUTTONS)) {
            state = START;
            break;
          }

        }

        // state = ?

        break;
      case LOSE:
        drawFullScreenImageDMA(wasted);
        final_score = score;

        if (final_score > high_score) {
            high_score = final_score;
        }

        char result1[30];
        char result2[30];
        while(1) {
          drawString(10, 10, "PRESS BACKSPACE TO START AGAIN", WHITE);

          drawString(140, 10, "YOUR SCORE: ", WHITE);
          sprintf(result1, "%d", final_score);
          drawString(140, 80, result1, WHITE); 
          drawString(150, 10, "HIGH SCORE: ", WHITE);
          sprintf(result2, "%d", high_score);
          drawString(150, 80, result2, WHITE); 


          if (KEY_DOWN(BUTTON_SELECT, BUTTONS)) {
            state = START;
            break;
          }

        }

        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
