#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/start.h"
#include "images/gradient.h"
#include "images/target.h"
/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //

  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  int score = 0;

  

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
    switch (state) {
      case START:
        drawFullScreenImageDMA(start);


        while(1) {
          drawString(130, 60, "PRESS UP TO START", WHITE);
          if (KEY_DOWN(BUTTON_UP, BUTTONS)) {
            drawRectDMA(0,0,WIDTH,HEIGHT,BLACK);
            state = PLAY;
            break;
          }

        }


        // state = ?
        break;
      case PLAY:;
        score = 0;
        char result[30];

        struct target_state cts, pts;
        struct g_target *tp, *otp;

        for (int i = 0; i < NUM_TILES; i++) {
          cts.targets[i].hit = 0;
        }


        struct ball *bp, *obp;
        struct state cs, ps;

        cs.gamestate = GS_INITBOUNCE;
        cs.size = 5;
        bp = &cs.balls;
        bp->row = 80;
        bp->col = 120;
        bp->rd = 2;
        bp->cd = 2;
        bp->color = WHITE;


        struct player *rp, *orp;
        struct player_state crs, prs;
        crs.width = 24;
        crs.height = 8;
        rp = &crs.players;
        rp -> row = 120;
        rp -> col = 120;
        rp -> rd = 3;
        rp -> cd = 3;
          // Run forever (or until the power runs out)
        
          while (1) {
            //score
            drawString(140, 10, "SCORE: ", WHITE);
            sprintf(result, "%d", score);
            drawRectDMA(140, 50, 20, 20, BLACK);
            drawString(140, 50, result, WHITE); 

            //tiles
              pts = cts;
              int row_disp = 0;
              int col_disp = 0;
              for (int i = 0; i < NUM_TILES; i++) {
                if (col_disp > 200) {
                  col_disp = 23;
                  row_disp += 20;
                } else {
                 col_disp += 23;

                }
                cts.targets[i].row = 10 + row_disp;
                cts.targets[i].col = col_disp;
                cts.targets[i].width = 20;
                cts.targets[i].height = 10;
              }
          // See if we need to bounce off a wall
              ps = cs;
              bp = &cs.balls;
              bp->row = bp->row + bp->rd;
              bp->col += bp->cd;
              if(bp->row < 0) {
                bp->row = 0;
                bp->rd = -bp->rd;
              }
              if(bp->row > HEIGHT - 5) {
                bp->row = HEIGHT - 5;
                bp->rd = -bp->rd;
              }
              if(bp->col < 0) {
                bp->col = 0;
                bp->cd = -bp->cd;
              }
              if(bp->col > WIDTH - 5) {
                bp->col = WIDTH - 5;
                bp->cd = -bp->cd;
              }
              if (((bp -> row > rp -> row && bp -> row < rp -> row + crs.height) || (bp -> row + cs.size > rp -> row && bp -> row + cs.size < rp -> row + crs.height)) && bp -> col > rp -> col && bp -> col < rp -> col + crs.width) {
                
                bp->rd = -bp->rd;

              }
              for (int i = 0; i < NUM_TILES; i++) {
                 if (cts.targets[i].hit == 0 && ((bp -> row > cts.targets[i].row && bp -> row < cts.targets[i].row + cts.targets[i].height) || (bp -> row + cs.size > cts.targets[i].row && bp -> row + cs.size < cts.targets[i].row + cts.targets[i].height)) && bp -> col > cts.targets[i].col && bp -> col < cts.targets[i].col + cts.targets[i].width) {
                
                    bp->rd = -bp->rd;
                    cts.targets[i].hit = 1;
                    score++;

                }
              }
          //player
              prs = crs;
              rp = &crs.players;
              if (KEY_DOWN(BUTTON_LEFT, BUTTONS)) {

                if (rp->col < 0) {
                  rp->col = 0;
                }
                rp->col = rp->col - rp->cd;
              }
              if (KEY_DOWN(BUTTON_RIGHT, BUTTONS)) {
                if (rp->col > WIDTH - 5 - crs.width) {
                  rp->col = WIDTH - 5 - crs.width;
                }
                rp->col = rp->col + rp->cd;
                
              }
          
// Draw the ball
              delay(1);
              waitForVBlank();
              for (int i = 0; i < NUM_TILES; i++) {

                otp = &pts.targets[i];
                if (otp->hit == 1) {
                  drawRectDMA(otp -> row, otp -> col, 20, 10, BLACK);
                } else {
                  continue;
                }
              }
              for (int i = 0; i < NUM_TILES; i++) {
                tp = &cts.targets[i];
                if (tp->hit == 0) {
                  drawImageDMA(tp -> row, tp -> col, 20, 10, target);
                } else {
                  continue;
                }
              }

              obp = &ps.balls;
              drawRectDMA(obp->row, obp->col,
                ps.size, ps.size,
                BLACK);
              bp = &cs.balls;
              drawRectDMA(bp->row, bp->col, cs.size, cs.size, bp->color);
              
              orp = &prs.players;
              drawRectDMA(orp->row, orp->col, prs.width, prs.height, BLACK);
              rp = &crs.players;
              drawImageDMA(rp->row, rp->col, crs.width, crs.height, gradient);
          } // Game Loop
           
        // state = ?
        break;
      case WIN:

        // state = ?
        break;
      case LOSE:

        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
